<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Mflow by markwoodhall</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Mflow</h1>
        <p class="header">A simple .net validation framework. </p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/markwoodhall/MFlow/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/markwoodhall/MFlow/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/markwoodhall/MFlow">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/markwoodhall">markwoodhall</a></p>


      </header>
      <section>
             <h2>Welcome to MFlow.</h2>

<p>
MFlow is a simple conditional logic/validation framework for .NET. 
<br />
<br />
<h3>Installing via nuget</h3>
<pre><code>
Install-Pacakge MFlow.Core 
</code></pre>
Or
<br /><br />
<pre><code>
Install-Package MFlow.Mvc
</code></pre>
Or
<br /><br />
<pre><code>
Install-Package MFlow.Client
</code></pre>
Installing the MFlow.Client packages also installs MFlow.Core & MFlow.Mvc and gives you the ability validate both server side and client side using a WebApi call. Like so:
<br /><br />
<pre><code>
$('#registerForm').MFlowClient('MFlow.Samples.Mvc, MFlow.Samples.Mvc.Models.RegisterModel', 
	{ 
		// validate the item on blur
		validateOnBlur: true, 
		// give a suggestion on focus
		suggestOnFocus: true, 
		validationErrorClass: 'input-validation-error', 
		validationValidClass: 'field-validation-valid',
		suggestionClass: 'input-validation-suggestion',
		validationUrl: '/api/Validation',
		suggestionUrl: '/api/Suggestion'
	});
	</code></pre>
The idea is to improve and give a more fluent approach to conditional and validation checking. Similar to the way that the fluentvalidation framework for .NET works. 
<br />
Example:<br /><br />
<pre><code>
fluentValidation
	.Check(u => u.Username).IsEqualTo("testing")
	.Check(u => u.Password).IsEqualTo("password123")
	.Check(u => u.Email).IsEmail()
	.Satisfied();
		</code></pre>		
A simple example like the one above can also be configured using XML:<br /><br />
<pre><code>
&lt;FluentValidation&gt;
  &lt;Validator&gt;
	&lt;Rules&gt;
	  &lt;Equal property="Username" value="testing" /&gt;
	  &lt;Equal property="Password" value="password123" /&gt;
	  &lt;IsEmail property="Email" /&gt;
	&lt;/Rules&gt;
  &lt;/Validator&gt;
&lt;/FluentValidation&gt;
</code></pre>         
Or VML...<br />
<code><pre>
[Display]  [When] Username [Is] NotEqual [To] testing
[Display]  [When] Username [Is] NotEqual [To] password123
[Display]  [When] Username [Is] NotAnEmail     
</pre></code>
In all three of the above examples when an explicit error message is not defined the following happens. 

The validator will look for a resource xml file for the current culture and derive a default message based on the condition applied. If a resource file does not exist for the current culture the default resource (Messages.en.xml) file will be used:
<br /><code><pre>
&lt;Messages>
  &lt;NotEmpty>{0} should not be empty&lt;/NotEmpty>
  &lt;Equal>{0} should be equal to {1}&lt;/Equal>
  &lt;NotEqual>{0} should not be equal to {1}&lt;/NotEqual>
  &lt;LessThan>{0} should be less than {1}&lt;/LessThan>
  &lt;LessThanOrEqualTo>{0} should be less than or equal to {1}&lt;/LessThanOrEqualTo>
  &lt;GreaterThan>{0} should be greater than {1}&lt;/GreaterThan>
  &lt;GreaterThanOrEqualTo>{0} should be greater than or equal to {1}&lt;/GreaterThanOrEqualTo>
  &lt;RegEx>{0} should validate expression {1}&lt;/RegEx>
  &lt;IsEmail>{0} should be an email&lt;/IsEmail>
  &lt;Contains>{0} should contain {1}&lt;/Contains>
  &lt;Before>{0} should be before {1}&lt;/Before>
  &lt;After>{0} should be after {1}&lt;/After>
  &lt;On>{0} should be on {1}&lt;/On>
&lt;/Messages>
</code></pre>
There is also, purely for example purposes a french resource file (Messages.fr-FR.xml) that looks like this:
<br /><br />
<pre><code>
&lt;Messages&gt;
  &lt;NotEmpty&gt;{0} ne doit pas être vide&lt;/NotEmpty&gt;
  &lt;Equal&gt;{0} doit être égale à {1}&lt;/Equal&gt;
  &lt;NotEqual&gt;{0} ne doit pas être égal à {1}&lt;/NotEqual&gt;
  &lt;LessThan&gt;{0} doit être inférieure à {1}&lt;/LessThan&gt;
  &lt;LessThanOrEqualTo&gt;{0} doit être inférieure ou égale à {1}&lt;/LessThanOrEqualTo&gt;
  &lt;GreaterThan&gt;{0} doit être supérieure à {1}&lt;/GreaterThan&gt;
  &lt;GreaterThanOrEqualTo&gt;{0} doit être supérieure ou égale à {1}&lt;/GreaterThanOrEqualTo&gt;
  &lt;RegEx&gt;{0} devrait valider l'expression {1}&lt;/RegEx&gt;
  &lt;IsEmail&gt;{0} doit être un e-mail&lt;/IsEmail&gt;
  &lt;Contains&gt;{0} doit contenir {1}&lt;/Contains&gt;
  &lt;Before&gt;{0} doit être avant {1}&lt;/Before&gt;
  &lt;After&gt;{0} devrait être après {1}&lt;/After&gt;
  &lt;On&gt;{0} doit être mis sur {1}&lt;/On&gt;
&lt;/Messages&gt;
</code></pre>
You can see from the quick example how easy it can be to setup some conditions and display the default validation messages in the correct culture for the user. 
    
The above resource files can also be extended. Creating a resource file called Custom.Messages.fr-FR for example like so:<br /><br />
<pre><code>
&lt;Messages&gt;
  &lt;EmailAddressShouldBeValid&gt;La valeur entrée doit être une adresse e-mail&lt;/EmailAddressShouldBeValid&gt;
&lt;/Messages&gt;
</code></pre>
You can then reference this custom error message in either the fluent interface, XML or VML like so:
<br />
Fluent Interface:<br /><br />
<pre><code>
fluentValidation
	.Check(u => u.Username).IsEmail().Message("$EmailAddressShouldBeValid$")
</code></pre>
XML:<br /><br />
<pre><code>
&lt;IsEmail property="Email" message="$EmailAddressShouldBeValid$" /&gt;
</code></pre>
VML:<br /><br />
<pre><code>
[Display] $EmailAddressShouldBeValid$ [When] Email [Is] NotAnEmail
</code></pre>
When you reference the error message like this, the same process described above will happen and the validator will attempt to load a message for the current culture first and then fall back to the default.
    <br /><br />
	<h3>Validators</h3>
The following validation checks are suported in the fluent interface/xml/vml config...
<br />
<h4>Generic:</h4><br />
<br />
IsEqual - C# Api is generic but only supports string validation in Xml/Vml,<br />
IsNotEqual - C# Api is generic but only supports string validation in Xml/Vml,<br />
IsRequired - C# Api is generic but only supports string validation in Xml/Vml,<br />
IsNotNull - C# Api is generic but only supports string validation in Xml/Vml,<br />
Any - Not supported in Xml/Vml,<br />
None - Not supported in Xml/Vml,<br />
<br />
<h4>Strings:</h4><br />
<br />
IsNotEmpty,<br />
IsEmail,<br />
IsLength,<br />
IsLongerThan,<br />
IsShorterThan,<br />
IsCreditCard,<br />
IsPostCode,<br />
IsZipCode,<br />
IsNumeric,<br />
IsAlpha,<br />
IsDate,<br />
Contains,<br />
Mathes (a regex),<br />
<br />
<h4>Numbers:</h4><br />
<br />
IsLessThan,<br />
IsGreaterThan,<br />
IsLessThanOrEqualTo,<br />
IsGreaterThanOrEqualTo,<br />
<br />
<h4>Dates:</h4><br />
<br />
IsBefore,<br />
IsAfter, <br />
IsOn,<br />
IsThisYear,<br />
IsThisMonth,<br />
IsThisWeek,<br />
IsToday<br /> </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>